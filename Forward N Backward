package org.firstinspires.ftc.teamcode;

import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.hardware.Gamepad;
import com.qualcomm.robotcore.eventloop.opmode.OpMode;      //for defining the behaviour of the robot during different phases
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;      //human-controlled (tele-op)
import com.qualcomm.robotcore.hardware.DcMotor;             //provides methods to control the motor
import com.qualcomm.robotcore.util.ElapsedTime;         //for measuring elapsed time in a program

@TeleOp(name="Forward N Back")
public class MoveNBack extends OpMode{     //declaring a java class
    private DcMotor leftDrive;            //represents the left motor of the two-motor drive system
    private DcMotor rightDrive;          //represents the right motor of the two-motor drive system
    private ElapsedTime runtime = new ElapsedTime();  
    
    private static final int distanceCentimeters = 100.0;     
    private static final double power = 0.5; 
    //Sets the desired distance
    
                          //Sets the desired power
    private static final int ticks_per_rev = 560;         //represents the number of encoder ticks generated by a motor for one full revolution
    private static final double wheel_diameter_cm = 9.0;        //represents the diameter of the wheel in centimeters, crucial for converting ticks into linear distance
    private static final double counts_per_cm = (double) ticks_per_rev / (wheel_diameter_cm * Math.PI);
    //represents the number of ticks per cm linear movement
    private static final double timeout_sec = 5.0;        //for calculating elapsed time within the code

    @Override
    public void init() { //initializing the robot's hardware
        leftDrive = hardwareMap.get(DcMotor.class, "leftDrive" );      //initializes the left motor with the variable 'leftMotor'
        rightDrive = hardwareMap.get(DcMotor.class, "rightDrive");     //initializes the right motor with the variable 'rightMotor'

        leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);    //left motor running using encoder meaning that the motor is controlled using encoder feedback
        rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);   //right motor run_using_encoder
        leftDrive.setDirection(DcMotor.Direction.FORWARD);  
        rightDrive.setDirection(DcMotor.Direction.FORWARD);
        //sets the direction of the left motor to reverse
    }

    @Override
    public void loop() {
        // Get the gamepad input
        double leftPower = gamepad1.left_stick_y;
        double rightPower = gamepad1.right_stick_y;

        // Set powers based on gamepad input
        setPowers(leftPower, rightPower);

        // Check if a specific button is pressed (assuming 'a' button in this case)
        if (gamepad1.y) {
            // Perform the distance movement when the 'y' button is pressed
            distance(distanceCentimeters, power);
        }
    }
    
    @Override
    public void init_loop() {
    }

    @Override
    public void start() {
    }

    public void setPowers(double leftPower, double rightPower) {      //provide a convenient way to set powers for a pair of motors while automatically normalizing them
        double largest = 1.0;                                    //initializes the variable largest with the value 1.0
        largest = Math.max(largest, Math.abs(leftPower));        //compares the absolute value of leftPower with the current value of 'largest'
        largest = Math.max(largest, Math.abs(rightPower));       //compares the absolute value of rightPower with the current value of 'largest'

        leftDrive.setPower(leftPower / largest);                 //sets the power of the left motor by dividing 'leftPower' by the value of 'largest'
        rightDrive.setPower(rightPower/ largest);                //sets the power of the right motor by dividing the 'rightPower' by the value of 'largest'
    }

    public void distance(int centimeters, double power) {
        int targetPosition = (int) (centimeters * counts_per_cm);

        leftDrive.setTargetPosition(leftDrive.getCurrentPosition() + targetPosition);
        rightDrive.setTargetPosition(rightDrive.getCurrentPosition() + targetPosition);

        leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        leftDrive.setPower(power);
        rightDrive.setPower(power);

        runtime.reset();

        while (leftDrive.isBusy() && rightDrive.isBusy() && runtime.seconds() < timeout_sec) {
        }

        //Stop the robot after moving forward
        leftDrive.setPower(0);
        rightDrive.setPower(0);
        
        leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);

        //Backward movement
        targetPosition = (int) (centimeters * counts_per_cm);
        leftDrive.setTargetPosition(leftDrive.getCurrentPosition() - targetPosition);
        rightDrive.setTargetPosition(rightDrive.getCurrentPosition() - targetPosition);

        leftDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        rightDrive.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        leftDrive.setPower(power); 
        rightDrive.setPower(power); 

        runtime.reset();

        while (leftDrive.isBusy() && rightDrive.isBusy() && runtime.seconds() < timeout_sec) {
        }

        //Stop the robot after moving backward
        leftDrive.setPower(0);
        rightDrive.setPower(0);
        
        leftDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
        rightDrive.setMode(DcMotor.RunMode.RUN_USING_ENCODER);
    }   
}

